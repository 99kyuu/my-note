<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="maximum-scale=1.0, minimum-scale=1.0, user-scalable=0, initial-scale=1.0, width=device-width"/>
	    <meta name="format-detection" content="telephone=no, email=no, date=no, address=no">
		<title>banner插件</title>
		<style media="screen">
			*{ padding: 0; margin: 0; }
			html,body{ font-size: 50px; color: #333; background: #fff; -webkit-touch-callout:none; -webkit-text-size-adjust:none; -webkit-tap-highlight-color:rgba(0, 0, 0, 0); -webkit-user-select:none; font-family: "Helvetica Neue", Helvetica, sans-serif; }
			li{ list-style: none; }
			span,img{ display: block; }
			/*定义rem*/
			@media only screen and (min-width: 400px) { html { font-size: 53.33333333px !important; } }
			@media only screen and (min-width: 414px) { html { font-size: 55.2px !important; } }
			@media only screen and (min-width: 480px) { html { font-size: 64px !important; } }
			.wrap{ width: 100%; max-width: 600px; margin: auto; }
			/* overflow: hidden; */
			.swiper{ width: 100%; height: 4rem; position: relative; background-color: #eee; overflow: hidden; }
			.swiper .swiper_list{ overflow: hidden; position: relative; width: 100%; -webkit-transition: 0s all; transition: 0s all; }
			.swiper .swiper_slider{ float: left; width: 100%; height: 4rem; background-color: #333; text-align: center; line-height: 4rem; color: #fff; }
			.swiper img{ width: 100%; }
			.swiper .swiper_pagination{ position: absolute; left: 50%; max-width: 100%; bottom: 10px; height: 8px; -webkit-transform: translateX(-50%); transform: translateX(-50%); overflow: auto; }
			.swiper .swiper_btn{ float: left; margin-left: 8px; width: 8px; height: 8px; background-color: rgba(0,0,0,0.5); border-radius: 50%; }
			.swiper .swiper_btn_active{ background-color: #fff; }
		</style>
	</head>
	<body>
		<section class="wrap">

		</section>
		<p onclick="addSwiper()" style="text-align: center">add a swiper</p>
	</body>
	<!-- <script type="text/javascript" src="./js/swiper.js"></script> -->
	<script type="text/javascript">
	var isClick = false;
	function addSwiper () {
		if (isClick) return ;
		isClick = !isClick;
		var _html = `<div class="swiper mybanner">
			<ul class="swiper_list">
				<li class="swiper_slider">
					<p>silder-1</p>
				</li>
				<li class="swiper_slider">
					<p>silder-2</p>
				</li>
				<li class="swiper_slider">
					<p>silder-3</p>
				</li>
			</ul>
			<div class="swiper_pagination"></div>
		</div>`;
		document.querySelector('.wrap').insertAdjacentHTML('beforeEnd',_html);
		new Swiper({
			el: '.mybanner',
			pagination: true,
			loop: true,
			moveTime: 400,
			direction: true
		})
	}
	// 动态生成html
	function createList(_num, isBtn, fn) {
		let [_swiper, _ul, _li, _btn] = [document.createElement('div'), document.createElement('ul'), '', document.createElement('div')];
		_swiper.className = 'swiper';
		_swiper.style.marginBottom = '.4rem';
		_ul.className = 'swiper_list';
		_btn.className = 'swiper_pagination';
		for (let i = 0; i < _num; i++) _li += `<li class="swiper_slider"><p>silder-${i+1}</p></li>`;
		_ul.innerHTML = _li;
		_swiper.appendChild(_ul);
		if (isBtn) _swiper.appendChild(_btn);
		document.querySelector('.wrap').appendChild(_swiper);
		if (typeof fn === 'function') fn.call(this);
	}
	createList(16, true, () => {
		new Swiper({
			el: '.swiper',
			pagination: true,
			autoPaly: true,
			interval: 3000,
			// loop: true,
			// moveTime: 400,
			// direction: true
		});
	});
	/*
		默认全部 false
		_pagination: 底部圆点（true & false）
		_loop：是否需要回路（true & false）
		_direction：X/Y方向（true & false）
		_moveTime：过渡时间（毫秒）
		_autoPaly： 自动播放（true & false）
		_interval： 自动播放间隔（秒）
	*/
	function Swiper (_params) {
		let [_pagination, _loop, _direction, _moveTime, _autoPaly, _interval] = [false, false, false, 300, false, 3000];
		// 触摸事件
		let touch = (_div, _w, _h) => {
			let _ul = _div.querySelector('.swiper_list');
			let _li = _ul.querySelectorAll('.swiper_slider');
			let _btn = _div.querySelectorAll('.swiper_btn');
			// 触摸开始时间，触摸结束时间，开始的距离，结束的距离，结束距离状态，移动的距离，圆点位置，自动播放定计算数值，loop定时器计算值
			let [sTime, eTime, _sd, _ed, _eState, _md, _index, _t, _loopNum] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
			// 选择方向距离
			let _distance = _direction ? _h : _w;
            // 定义 requestAnimationFrame
			window.myAnimation = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
			// 设置动画
			function hasAnimation() {
				_ul.style.WebkitTransition = _moveTime/1000+'s all';
				_ul.style.transition = _moveTime/1000+'s all';
			}
			// 关闭动画
			function noAnimation() {
				_ul.style.WebkitTransition = '0s all';
				_ul.style.transition = '0s all'
			}
            // 属性样式
			function slideStyle(_num) {
				if (_direction) {
					_ul.style.WebkitTransform = `translate3d(0px, ${_num}px, 0px)`;
					_ul.style.transform = `translate3d(0px, ${_num}px, 0px)`;
				}else {
					_ul.style.WebkitTransform = `translate3d(${_num}px, 0px, 0px)`;
					_ul.style.transform = `translate3d(${_num}px, 0px, 0px)`;
				}
			}
			// 判断最大拖动距离
			function touchRange() {
				let _num = 0;
				if ((_ed - _sd) >= _distance) {
					_num = _md + _distance;
				}else if ((_ed - _sd) <= -_distance) {
					_num = _md - _distance
				}else {
					_num = _md + (_ed - _sd);
				}
				return _num;
			}
			// 判断触摸处理函数 _d是距离X/Y
			function judgeTouch(_d) {
				//	这里我设置了200毫秒的有效拖拽间隔
				if ((eTime - sTime) < 200) return true;
				// 这里判断方向（正值和负值）
				if (_d < 0) {
					if ((_ed - _sd) < (_d/2)) return true;
					return false
				}else {
					if ((_ed - _sd) > (_d/2)) return true;
					return false
				}
			}
			// 返回原来位置
			function returnP () {
				hasAnimation();
				slideStyle(_md);
			}
			// 移动
			function slideMove (_d) {
				hasAnimation();
				slideStyle(_d);
				_loopNum = 0;
				// 判断loop时回到第一张或最后一张
				if (_loop && _index < 0) {
					// 我这里是想让滑块过渡完之后再重置位置所以加的延迟 (之前用setTimeout，快速滑动有问题，然后换成 requestAnimationFrame解决了这类问题)
					function loopMoveMin() {
						_loopNum += 1;
						if (_loopNum < _moveTime/1000*60) return myAnimation(loopMoveMin);
						noAnimation();
						slideStyle(_distance * -(_li.length-3));
						// 重置一下位置
						_md = _distance * -(_li.length-3);
					}
					loopMoveMin()
					_index = _li.length-3;
				}else if (_loop && _index > _li.length-3) {
					function loopMoveMax() {
						_loopNum += 1;
						if (_loopNum < _moveTime/1000*60) return myAnimation(loopMoveMax);
						noAnimation();
						slideStyle(0);
						_md = 0;
					}
					loopMoveMax()
					_index = 0;
				}
				if (_pagination) {
					_div.querySelector('.swiper_btn_active').className = 'swiper_btn';
					_btn[_index].classList.add('swiper_btn_active');
				}
			}
			// 判断移动
			function judgeMove() {
				// 判断是否需要执行过渡
				if (_ed < _sd) {
					// 往上滑动 or 向左滑动
					if (judgeTouch(-_distance)) {
						// 判断有loop的时候不需要执行下面的事件
						if (!_loop && _md === -(_li.length-1) * _distance) return returnP();
						_index += 1;
						slideMove(_md - _distance);
						_md -= _distance;
					}else returnP();
				}else {
					// 往下滑动 or 向右滑动
					if (judgeTouch(_distance)) {
						if (!_loop && _md === 0) return returnP();
						_index -= 1;
						slideMove(_md + _distance);
						_md += _distance;
					}else returnP();
				}
			}
			// 自动播放移动
			function autoMove() {
				// 这里判断是否有回路loop的自动播放
				if (_loop) {
					_index += 1;
					slideMove(_md - _distance);
					_md -= _distance;
				}else {
					if (_index >= _li.length-1) {
						_index = 0;
						slideMove(0);
						_md = 0;
					}else {
						_index += 1;
						slideMove(_md - _distance);
						_md -= _distance;
					}
				}
			}
			// 首次开启自动播放
			function startAuto () {
				_t += 1;
				//	这里是1秒60次
				if (_t < _interval/1000*60) return myAnimation(startAuto);
				_t = 0;
				autoMove();
				startAuto()
			}
			if (_autoPaly) startAuto();
			// 开始触摸
			_ul.addEventListener('touchstart', ev => {
				// _loopNum = _moveTime/1000*60;
				[sTime, _t, _loopNum] = [new Date().getTime(), 0, _moveTime/1000*60]
				noAnimation();
				_sd = _direction ? ev.touches[0].pageY : ev.touches[0].pageX;
			});
			// 触摸移动
			_ul.addEventListener('touchmove', ev => {
				ev.preventDefault();
				_t = 0;
				_ed = _direction ? ev.touches[0].pageY : ev.touches[0].pageX;
				slideStyle(touchRange());
			});
			// 触摸离开
			_ul.addEventListener('touchend', () => {
				eTime = new Date().getTime();
				// 判断如果是点击的话就不执行移动
				if (_eState !== _ed) judgeMove();
				console.log(`new:${_index}`);	//这里可以做触发回调
				// 更新位置 && 重新打开自动播放要放到最后
				[_eState, _t] = [_ed, 0];
			});
		}
		// 动态布局
		let layout = (_div, _w, _h) => {
			let _ul = _div.querySelector('.swiper_list');
			let _li = _div.querySelectorAll('.swiper_slider');
			if (_direction) {
				for (let i = 0; i < _li.length; i++) {
					_li[i].style.height = _h + 'px';
				}
			}else {
				_ul.style.width = _w * _li.length + 'px';
				for (let i = 0; i < _li.length; i++) {
					_li[i].style.width = _w + 'px';
				}
			}
			touch(_div, _w, _h);
		}
		// 如果要回路的话前后增加元素
		let outputLoop = (_div, _w, _h) => {
			let _ul = _div.querySelector('.swiper_list');
			let _li = _ul.querySelectorAll('.swiper_slider');
			let _first = _li[0].cloneNode(true);
			let _last = _li[_li.length-1].cloneNode(true);
			_ul.insertBefore(_last, _li[0]);
			_ul.appendChild(_first);
			if (_direction) {
				_ul.style.top = -_h + 'px';
			}else {
				_ul.style.left = -_w + 'px';
			}
			layout(_div, _w, _h)
		}
		// 输出底部圆点
		let outputPagination = _div => {
			let _btnList = _div.querySelector('.swiper_pagination');
			let _liNum = _div.querySelectorAll('.swiper_slider').length;
			let _html = '';
			for (let i = 0; i < _liNum; i++) {
				_html += '<div class="swiper_btn"></div>'
			}
			_btnList.innerHTML = _html;
			_btnList.querySelector('.swiper_btn').classList.add('swiper_btn_active');
		}
		// 动态布局初始化
		let format = _el => {
			let _swiper = document.querySelector(_el);
			let _moveWidth = _swiper.offsetWidth;
			let _moveHeight = _swiper.offsetHeight;
			if (_pagination) outputPagination(_swiper);
			if (_loop) {
				outputLoop(_swiper,_moveWidth,_moveHeight);
			}else {
				layout(_swiper,_moveWidth,_moveHeight);
			}
		}
		// 配置传参
		let init = () => {
			_pagination = _params.pagination || false;
			_direction = _params.direction || false;
			_autoPaly = _params.autoPaly || false;
			_loop = _params.loop || false;
			_moveTime = _params.moveTime || 300;
			_interval = _params.interval || 3000;
			if (!_params.el) return console.log('没有可执行的元素！');
			format(_params.el);
		}
		init();
	}
	</script>
</html>
