<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="maximum-scale=1.0, minimum-scale=1.0, user-scalable=0, initial-scale=1.0, width=device-width"/>
	    <meta name="format-detection" content="telephone=no, email=no, date=no, address=no">
		<title>banner插件</title>
		<style media="screen">
			*{ padding: 0; margin: 0; }
			html,body{ font-size: 50px; color: #333; background: #fff; -webkit-touch-callout:none; -webkit-text-size-adjust:none; -webkit-tap-highlight-color:rgba(0, 0, 0, 0); -webkit-user-select:none; font-family: "Helvetica Neue", Helvetica, sans-serif; }
			li{ list-style: none; }
			span,img{ display: block; }
			/*定义rem*/
			@media only screen and (min-width: 400px) { html { font-size: 53.33333333px !important; } }
			@media only screen and (min-width: 414px) { html { font-size: 55.2px !important; } }
			@media only screen and (min-width: 480px) { html { font-size: 64px !important; } }
			.wrap{ width: 100%; max-width: 600px; margin: auto; }
			/* overflow: hidden; */
			.swiper{ width: 100%; height: 4rem; position: relative; background-color: #eee; overflow: hidden; }
			.swiper .swiper_list{ overflow: hidden; position: relative; width: 100%; -webkit-transition: 0s all; transition: 0s all; }
			.swiper .swiper_slider{ float: left; width: 100%; height: 4rem; background-color: #333; text-align: center; line-height: 4rem; color: #fff; }
			.swiper img{ width: 100%; }
			.swiper .swiper_pagination{ position: absolute; width: 100%; height: 10px; bottom: 48px; left: 0; text-align: center; }
			.swiper .swiper_btn{ display: inline-block; margin-left: 8px; width: 8px; height: 8px; background-color: rgba(0,0,0,0.5); border-radius: 50%; }
			.swiper .swiper_btn_active{ background-color: #fff; }
		</style>
	</head>
	<body>
		<section class="wrap"></section>
		<p onclick="addSwiper(this)" style="text-align: center">add a swiper</p>
		<!-- <script type="text/javascript" src="./js/swiper.js"></script> -->
		<script type="text/javascript">
			function addSwiper (el) {
				var _html = `<div class="swiper mybanner">
								<ul class="swiper_list">
									<li class="swiper_slider">
										<p>silder-1</p>
									</li>
									<li class="swiper_slider">
										<p>silder-2</p>
									</li>
									<li class="swiper_slider">
										<p>silder-3</p>
									</li>
								</ul>
								<div class="swiper_pagination"></div>
							</div>`;
				document.querySelector('.wrap').insertAdjacentHTML('beforeEnd',_html);
				new Swiper({
					el: '.mybanner',
					pagination: true,
					loop: true,
					moveTime: 400,
					direction: true
				})
				el.parentNode.removeChild(el)
			}
			// 动态生成html
			function createList(_num, isBtn, fn) {
				let [_swiper, _ul, _li, _btn] = [document.createElement('div'), document.createElement('ul'), '', document.createElement('div')];
				_swiper.className = 'swiper';
				_swiper.style.marginBottom = '.4rem';
				_ul.className = 'swiper_list';
				_btn.className = 'swiper_pagination';
				for (let i = 0; i < _num; i++) _li += `<li class="swiper_slider"><p>silder-${i+1}</p></li>`;
				_ul.innerHTML = _li;
				_swiper.appendChild(_ul);
				if (isBtn) _swiper.appendChild(_btn);
				document.querySelector('.wrap').appendChild(_swiper);
				if (typeof fn === 'function') fn.call(this);
			}
			createList(3, true, () => {
				new Swiper({
					el: '.swiper',
					pagination: true,
					autoPaly: true,
					interval: 3000,
					// loop: true,
					// moveTime: 400,
					// direction: true
				});
			});
			/*
			*	默认全部 false
			*	_pagination: 底部圆点（true & false）
			*	_loop：是否需要回路（true & false）
			*	_direction：X/Y方向（true & false）
			*	_moveTime：过渡时间（毫秒）
			*	_autoPaly： 自动播放（true & false）
			*	_interval： 自动播放间隔（秒）
			*/
			function Swiper(_params) {
				let _pagination = false, _loop = false, _direction = false, _autoPaly = false, _interval = 3000, _moveTime = 300;
				// 触摸事件
				function _touch(_div, _w, _h) {
					let _ul = _div.querySelector('.swiper_list');
					let _li = _ul.querySelectorAll('.swiper_slider');
					let _btn = _div.querySelectorAll('.swiper_btn');
					// 触摸开始时间，触摸结束时间，开始的距离，结束的距离，结束距离状态，移动的距离，圆点位置，自动播放定计算数值，loop定时器计算值
					let sTime = 0, eTime = 0, _sd = 0, _ed = 0, _eState = 0, _md = 0, _index = 0, _t = 0, _loopNum = 0,
					// 选择方向距离
					_distance = _direction ? _h : _w,
					// 定义 requestAnimationFrame
					myAnimation = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
					// 设置动画
					function hasAnimation() {
						_ul.style.WebkitTransition = `${_moveTime / 1000}s all`;
						_ul.style.transition = `${_moveTime / 1000}s all`;
					}
					// 关闭动画
					function noAnimation() {
						_ul.style.WebkitTransition = '0s all';
						_ul.style.transition = '0s all';
					}
					// 属性样式
					function slideStyle(_num) {
						if (_direction) {
							_ul.style.WebkitTransform = `translate3d(0px, ${_num}px, 0px)`;
							_ul.style.transform = `translate3d(0px, ${_num}px, 0px)`;
						} else {
							_ul.style.WebkitTransform = `translate3d(${_num}px, 0px, 0px)`;
							_ul.style.transform = `translate3d(${_num}px, 0px, 0px)`;
						}
					}
					// 判断最大拖动距离
					function touchRange() {
						let _num = 0;
						// 默认这个公式
						_num = _md + (_ed - _sd);
						// 判断最大正负值
						if ((_ed - _sd) >= _distance) {
							_num = _md + _distance;
						} else if ((_ed - _sd) <= -_distance) {
							_num = _md - _distance;
						}
						// _md : 移动的距离 _ed : 结束的距离 _sd 开始的距离
						// 没有loop的时候惯性拖拽
						if (!_loop) {
							if ((_ed - _sd) > 0 && _index === 0) {
								// console.log('到达最初');
								_num = _md + ((_ed - _sd) - ((_ed - _sd) * 0.6));
							} else if ((_ed - _sd) < 0 && _index === _li.length - 1) {
								// console.log('到达最后');
								_num = _md + ((_ed - _sd) - ((_ed - _sd) * 0.6));
							}
						}
						return _num;
					}
					// 判断触摸处理函数 _d是距离X/Y
					function judgeTouch(_d) {
						//	这里我设置了200毫秒的有效拖拽间隔
						if ((eTime - sTime) < 200) return true;
						// 这里判断方向（正值和负值）
						if (_d < 0) {
							if ((_ed - _sd) < (_d / 2)) return true;
							return false;
						} else {
							if ((_ed - _sd) > (_d / 2)) return true;
							return false;
						}
					}
					// 返回原来位置
					function returnLocation() {
						hasAnimation();
						slideStyle(_md);
					}
					// 移动
					function slideMove(_d) {
						hasAnimation();
						slideStyle(_d);
						_loopNum = 0;
						// 判断loop时回到第一张或最后一张
						if (_loop && _index < 0) {
							// 我这里是想让滑块过渡完之后再重置位置所以加的延迟 (之前用setTimeout，快速滑动有问题，然后换成 requestAnimationFrame解决了这类问题)
							function loopMoveMin() {
								_loopNum += 1;
								if (_loopNum < _moveTime / 1000 * 60) return myAnimation(loopMoveMin);
								noAnimation();
								slideStyle(_distance * -(_li.length - 3));
								// 重置一下位置
								_md = _distance * -(_li.length - 3);
							}
							loopMoveMin();
							_index = _li.length - 3;
						} else if (_loop && _index > _li.length - 3) {
							function loopMoveMax() {
								_loopNum += 1;
								if (_loopNum < _moveTime / 1000 * 60) return myAnimation(loopMoveMax);
								noAnimation();
								slideStyle(0);
								_md = 0;
							}
							loopMoveMax();
							_index = 0;
						}
						// console.log(`第${ _index+1 }张`);	// 这里可以做滑动结束回调
						if (_pagination) {
							_div.querySelector('.swiper_btn_active').className = 'swiper_btn';
							_btn[_index].classList.add('swiper_btn_active');
						}
					}
					// 判断移动
					function judgeMove() {
						// 判断是否需要执行过渡
						if (_ed < _sd) {
							// 往上滑动 or 向左滑动
							if (judgeTouch(-_distance)) {
								// 判断有loop的时候不需要执行下面的事件
								if (!_loop && _md === (-(_li.length - 1) * _distance)) return returnLocation();
								_index += 1;
								slideMove(_md - _distance);
								_md -= _distance;
							} else returnLocation();
						} else {
							// 往下滑动 or 向右滑动
							if (judgeTouch(_distance)) {
								if (!_loop && _md === 0) return returnLocation();
								_index -= 1;
								slideMove(_md + _distance);
								_md += _distance;
							} else returnLocation();
						}
					}
					// 自动播放移动
					function autoMove() {
						// 这里判断是否有回路loop的自动播放
						if (_loop) {
							_index += 1;
							slideMove(_md - _distance);
							_md -= _distance;
						} else {
							if (_index >= _li.length - 1) {
								_index = 0;
								slideMove(0);
								_md = 0;
							} else {
								_index += 1;
								slideMove(_md - _distance);
								_md -= _distance;
							}
						}
					}
					// 自动播放
					function startAuto() {
						_t += 1;
						//	这里帧数是1秒60次
						if (_t < _interval / 1000 * 60) return myAnimation(startAuto);
						_t = 0;
						autoMove();
						startAuto();
					}
					// 判断是否需要开启自动播放
					if (_autoPaly && _li.length - 1) startAuto();
					// 开始触摸
					_ul.addEventListener('touchstart', ev => {
						// _loopNum = _moveTime/1000*60;
						[sTime, _t, _loopNum] = [new Date().getTime(), 0, _moveTime / 1000 * 60];
						noAnimation();
						_sd = _direction ? ev.touches[0].pageY : ev.touches[0].pageX;
					});
					// 触摸移动
					_ul.addEventListener('touchmove', ev => {
						ev.preventDefault();
						_t = 0;
						_ed = _direction ? ev.touches[0].pageY : ev.touches[0].pageX;
						slideStyle(touchRange());
					});
					// 触摸离开
					_ul.addEventListener('touchend', () => {
						eTime = new Date().getTime();
						// 判断是否点击
						if (_eState !== _ed) {
							judgeMove();
						} else {
							// console.log('执行');
							returnLocation();
						}
						// console.log(`index: ${_index}`);	//  这里可以做触摸之后位置回调
						// 更新位置 && 重新打开自动播放要放到最后
						[_eState, _t] = [_ed, 0];
					});
				}
				// 动态布局
				function layout(_div, _w, _h) {
					let _ul = _div.querySelector('.swiper_list'), _li = _div.querySelectorAll('.swiper_slider');
					if (_direction) {
						for (let i = 0; i < _li.length; i++) {
							_li[i].style.height = `${_h}px`;
						}
					} else {
						_ul.style.width = `${_w * _li.length}px`;
						for (let i = 0; i < _li.length; i++) {
							_li[i].style.width = `${_w}px`;
						}
					}
					_touch(_div, _w, _h);
				}
				// 如果要回路的话前后增加元素
				function outputLoop(_div, _w, _h) {
					let _ul = _div.querySelector('.swiper_list');
					let _li = _ul.querySelectorAll('.swiper_slider');
					let _first = _li[0].cloneNode(true),
					_last = _li[_li.length - 1].cloneNode(true);
					_ul.insertBefore(_last, _li[0]);
					_ul.appendChild(_first);
					if (_direction) {
						_ul.style.top = `${-_h}px`;
					} else {
						_ul.style.left = `${-_w}px`;
					}
					layout(_div, _w, _h);
				}
				// 输出底部圆点
				function outputPagination(_div) {
					let _btnList = _div.querySelector('.swiper_pagination'),
					_liNum = _div.querySelectorAll('.swiper_slider').length,
					_html = '';
					for (let i = 0; i < _liNum; i++) {
						_html += '<div class="swiper_btn"></div>';
					}
					_btnList.innerHTML = _html;
					_btnList.querySelector('.swiper_btn').classList.add('swiper_btn_active');
				}
				// 动态布局初始化
				function format(_el) {
					let _swiper = document.querySelector(_el);
					let _moveWidth = _swiper.offsetWidth, _moveHeight = _swiper.offsetHeight;
					if (_pagination) outputPagination(_swiper);
					if (_loop) {
						outputLoop(_swiper, _moveWidth, _moveHeight);
					} else {
						layout(_swiper, _moveWidth, _moveHeight);
					}
				}
				// 配置传参
				function init() {
					if (!_params.el) return console.warn('没有可执行的元素！');
					_pagination = _params.pagination || false;
					_direction = _params.direction || false;
					_autoPaly = _params.autoPaly || false;
					_loop = _params.loop || false;
					_moveTime = _params.moveTime || 300;
					_interval = _params.interval || 3000;
					format(_params.el);
				}
				init();
			}
		</script>
	</body>
</html>
