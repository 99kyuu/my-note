<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="maximum-scale=1.0, minimum-scale=1.0, user-scalable=0, initial-scale=1.0, width=device-width"/>
		<meta name="format-detection" content="telephone=no, email=no, date=no, address=no">
		<title>下拉刷新</title>
		<link rel="stylesheet" href="./css/base.css">
		<link rel="stylesheet" href="./css/loading.css">
		<link rel="stylesheet" href="./css/refresh.css">
		<style media="screen">
			body {
				background-color: #eee;
			}

			.wrap li {
				background-color: gold;
				height: 5rem;
				position: relative;
				z-index: 10;
			}

			.wrap li:nth-child(even) {
				background-color: #212121;
			}
		</style>
	</head>
	<body>
		<div class="wrap">
			<ul>
				<li></li>
			</ul>
		</div>
		<!-- 下拉头部状态节点模板 -->
		<script type="text/template">
			<div class="refresh_title">
				<!-- icon -->
				<div class="icon_refresh"></div>
				<!-- 旋转的圈圈 -->
				<div class="preloader hide">
					<span class="preloader-inner">
						<span class="preloader-inner-gap"></span>
						<span class="preloader-inner-left">
							<span class="preloader-inner-half-circle"></span>
						</span>
						<span class="preloader-inner-right">
							<span class="preloader-inner-half-circle"></span>
						</span>
					</span>
				</div>
			</div>
		</script>
		<script type="text/javascript">
			var _html = ''
			for (let i = 0; i < 20; i++) {
				_html += '<li></li>'
			}
			document.querySelector('.wrap ul').innerHTML = _html;
			/**
			 * 这里我做的不是用window的滚动事件，而是用最外层的绑定触摸下拉事件去实现
			 * 好处是我用在Vue这类单页应用的时候，路由销毁时不用去解绑window的scroll事件
			 * 但是滑动到底部事件就必须要用window的scroll事件，这点需要注意
			*/

			class DropDownRefresh {
				constructor(el) {
					if (!el) return console.warn('没有可下拉的元素');
					this.page = document.querySelector(el);
					this.layer = document.createElement('div');
					this.layer.style.cssText = 'position: fixed;top: 0;left: 0;width: 100%;height: 100%;background-color: rgba(0,0,0,0);z-index: 100;';
					// 下拉刷新的提示元素
					this.pagetitle = document.createElement('div');
					this.pagetitle.className = 'refresh_title';
					this.pagetitle.innerHTML = '<div class="icon_refresh"></div><div class="preloader hide"><span class="preloader-inner"><span class="preloader-inner-gap"></span><span class="preloader-inner-left"><span class="preloader-inner-half-circle"></span></span><span class="preloader-inner-right"><span class="preloader-inner-half-circle"></span></span></span></div>';
				}
				// 设置动画
				getAnimation(time) {
					this.page.style.WebkitTransition = this.page.style.transition = `${time}s all`;
					this.pagetitle.style.WebkitTransition = this.pagetitle.style.transition = `${time}s all`;
				}
				// 滑动样式
				setStyle(num) {
					this.page.style.WebkitTransform = this.page.style.transform = `translate3d(0px, ${num}px, 0px)`;
					this.pagetitle.style.WebkitTransform = this.pagetitle.style.transform = `translate3d(0px, ${num}px, 0px)`;
				}
				// 开始刷新
				start(max = 100, callback, rangeCallback) {
					let rootNode = 0,
						icon = this.pagetitle.querySelector('.icon_refresh'),
						loading = this.pagetitle.querySelector('.preloader'),
						sd = 0,	// 开始距离
						ed = 0,	// 结束距离
						range = 0;	// 最后移动的距离
					// 开始执行就添加提示头部
					this.page.parentNode.insertBefore(this.pagetitle, this.page);
					this.pagetitle.style.height = max + 'px';
					this.pagetitle.style.top = -max + 'px';
					// 触摸开始
					this.page.addEventListener('touchstart', ev => {
						sd = ev.touches[0].pageY;
						this.getAnimation(0);
					});
					// 触摸移动
					this.page.addEventListener('touchmove', ev => {
						rootNode = document.documentElement.scrollTop === 0 ? document.body.scrollTop : document.documentElement.scrollTop;
						// 没到达顶部就停止
						if (rootNode != 0) return;
						ed = ev.touches[0].pageY;
						range = Math.floor(ed - sd);
						// 判断如果是下滑才执行
						if (range > 0) {
							// 阻止浏览自带的下拉效果
							ev.preventDefault();
							// 最主要的物理回弹公式计算距离
							range = range - (range * 0.5);
							// 下拉时icon旋转
							icon.style.WebkitTransform = icon.style.transform = `rotate(${180 * (range / max)}deg)`;
							if (range > max) {
								icon.classList.add('hide');
								loading.classList.remove('hide');
							} else {
								icon.classList.remove('hide');
								loading.classList.add('hide');
							}
							this.setStyle(range);
							// 回调距离函数 如果有需要
							if (typeof rangeCallback === 'function') rangeCallback(range);
						}
					});
					// 触摸结束
					this.page.addEventListener('touchend', ev => {
						this.getAnimation(0.3);
						// console.log(`移动的距离：${range}, 最大距离：${max}`);
						if (range > max && range > 1 && rootNode == 0) {
							this.setStyle(max);
							document.body.appendChild(this.layer);
							// 阻止往上滑动
							this.layer.ontouchmove = e => e.preventDefault();
							// 回调成功下拉到最大距离并松开函数
							if (typeof callback === 'function') callback.call(this);
						} else {
							this.setStyle(0);
						}
					});
				}
				// 下拉结束
				end() {
					this.layer.parentNode.removeChild(this.layer);
					this.getAnimation(0.3);
					this.setStyle(0);
				}
			}
			// 调用
			let Ddr = new DropDownRefresh('.wrap');
			Ddr.start(100, function () {
				console.log('下拉成功');
				setTimeout(function () {
					Ddr.end();
				}, 2000);
			}, function (num) {
				console.log('下拉的距离：', num);
			});

			/**
			 * ES5 原型链定义
			*/
			var Refresh = function (el) {
				if (!el) return console.log('没有可下拉的元素');
				this.page = document.querySelector(el);
				this.layer = document.createElement('div');
				this.layer.style.cssText = 'position: fixed;top: 0;left: 0;width: 100%;height: 100%;background-color: rgba(0,0,0,0);z-index: 100;';
				// 下拉刷新的提示元素
				this.pagetitle = document.createElement('div');
				this.pagetitle.className = 'refresh_title';
				this.pagetitle.innerHTML = '<div class="icon_refresh"></div><div class="preloader hide"><span class="preloader-inner"><span class="preloader-inner-gap"></span><span class="preloader-inner-left"><span class="preloader-inner-half-circle"></span></span><span class="preloader-inner-right"><span class="preloader-inner-half-circle"></span></span></span></div>';
			}
			Refresh.prototype = {
				// 设置动画
				getAnimation: function (time) {
					this.page.style.WebkitTransition = this.page.style.transition = time + 's all';
					this.pagetitle.style.WebkitTransition = this.pagetitle.style.transition = time + 's all';
				},
				// 滑动样式
				setStyle: function (num) {
					this.page.style.WebkitTransform = this.page.style.transform = 'translate3d(0px, ' + num + 'px, 0px)';
					this.pagetitle.style.WebkitTransform = this.pagetitle.style.transform = 'translate3d(0px, ' + num + 'px, 0px)';
				},
				// 开始刷新
				start: function (max, callback, rangeCallback) {
					var rootNode = 0,
						icon = this.pagetitle.querySelector('.icon_refresh'),
						loading = this.pagetitle.querySelector('.preloader'),
						sd = 0,
						ed = 0,
						range = 0,
						max = max || 100,
						_self = this;
					this.page.parentNode.insertBefore(this.pagetitle, this.page);
					this.pagetitle.style.height = max + 'px';
					this.pagetitle.style.top = -max + 'px';
					this.page.addEventListener('touchstart', function (ev) {
						sd = ev.touches[0].pageY;
						_self.getAnimation(0);
					});
					this.page.addEventListener('touchmove', function (ev) {
						rootNode = document.documentElement.scrollTop === 0 ? document.body.scrollTop : document.documentElement.scrollTop;
						if (rootNode != 0) return;
						ed = ev.touches[0].pageY;
						range = Math.floor(ed - sd);
						if (range > 0) {
							ev.preventDefault();
							range = range - (range * 0.5);
							icon.style.WebkitTransform = icon.style.transform = 'rotate(' + 180 * (range / max) + 'deg)';
							if (range > max) {
								icon.classList.add('hide');
								loading.classList.remove('hide');
							} else {
								icon.classList.remove('hide');
								loading.classList.add('hide');
							}
							_self.setStyle(range);
							if (typeof rangeCallback === 'function') rangeCallback(range);
						}
					});
					this.page.addEventListener('touchend', function (ev) {
						_self.getAnimation(0.3);
						if (range > max && range > 1 && rootNode == 0) {
							_self.setStyle(max);
							document.body.appendChild(_self.layer);
							_self.layer.ontouchmove = function (e) {
								e.preventDefault();
							}
							if (typeof callback === 'function') callback.call(_self);
						} else {
							_self.setStyle(0);
						}
					});
				},
				// 下拉结束
				end: function () {
					this.layer.parentNode.removeChild(this.layer);
					this.getAnimation(0.3);
					this.setStyle(0);
				}
			}
		</script>
	</body>
</html>